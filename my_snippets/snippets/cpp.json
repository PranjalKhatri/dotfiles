{
	"Boilerplate": {
		"prefix": "BoilerPlate",
		"body": [
			"// clang-format off",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define USACO(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);",
			"#define int long long",
			"#define MOD 1000000007",
			"#define vi vector<int>",
			"#define vvi vector<vector<int>>",
			"#define pii pair<int,int>",
			"#define all(x) (x).begin(),(x).end()",
			"#define input(v, n) for (int i = 0; i < n; i++) cin >> v[i];",
			"",
			"struct Edge{int u,v,weight;bool operator<(Edge const&other)const{return weight < other.weight;}};",
			"template<typename T1,typename T2> ostream& operator<<(ostream& out,const pair<T1,T2> a){out<<a.first<<\" \"<<a.second;return out;}",
			"// clang-format on",
			"",
			"void compute()",
			"{",
			"    $0",
			"}",
			"signed main()",
			"{",
			"ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);",
			"    int t = 1;",
			"    cin>>t;",
			"    while(t--)compute();",
			"    return 0;",
			"}"
		],
		"description": "Log output to console"
	},
	"BinarySearch": {
		"prefix": "binary_template",
		"body": [
			"",
			"auto check = [&](int x)",
			"{",
			"    ${1}",
			"    return true; ",
			"};",
			"",
			"int lo = -1,hi=1e18;",
			"while (lo +1  < hi)",
			"{",
			"    int mid = lo + (hi - lo) / 2;",
			"    if (check(mid))",
			"    {",
			"        hi = mid; ",
			"    }",
			"    else ",
			"    {",
			"        lo = mid; ",
			"    }",
			"}",
			"",
			"cout<<lo<<\"\\n\"; ",
			""
		]
	},
	"exponentiate": {
		"prefix": "exponentiate",
		"body": [
			"int bin_pow(int x,int n,int m = 1e9+7)",
			"{",
			"    if (n == 0) return 1%m;",
			"    long long u = bin_pow(x,n/2,m);",
			"    u = (u*u)%m;",
			"    if (n%2 == 1) u = (u*x)%m;",
			"        return u;",
			"}"
		]
	},
	"BFS Function": {
		"prefix": "bfs",
		"body": [
			"void bfs(vector<vector<int>>&adjl) {",
			"    int s = 0;",
			"    queue<int> q;",
			"    q.push(s);",
			"",
			"    vector<bool> visited(adjl.size(), false); ",
			"    vector<int> distance(adjl.size(), 0);",
			"",
			"    visited[s] = true;",
			"    distance[s] = 0;",
			"",
			"    while (!q.empty()) {",
			"        int n = q.front();",
			"        q.pop();",
			"",
			"        ${0}",
			"        for (auto i : adjl[n]) {",
			"            if (visited[i])",
			"                continue;",
			"            distance[i] = distance[n] + 1; ",
			"            visited[i] = true;            ",
			"            q.push(i);                     ",
			"        }",
			"    }",
			"}"
		],
		"description": "Breadth-First Search (BFS) function implementation"
	},
	"DFS Function": {
		"prefix": "dfs",
		"body": [
			"void dfs(int s, vector<vector<int>> &adjl,vector<bool>& visited)",
			"{",
			"    if (visited[s])",
			"        return;",
			"    visited[s] = true;",
			"    // process node s",
			"    for (auto u : adjl[s])",
			"    {",
			"        dfs(u,adjl,visited);",
			"    }",
			"}"
		]
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"const int MAXN = 1000000;",
			"std::vector<int> prime;",
			"bool is_composite[MAXN];",
			"",
			"void sieve(int n) {",
			"    std::fill(is_composite, is_composite + n, false);",
			"    for (int i = 2; i < n; ++i) {",
			"        if (!is_composite[i]) prime.push_back(i);",
			"        for (int j = 0; j < prime.size() && i * prime[j] < n; ++j) {",
			"            is_composite[i * prime[j]] = true;",
			"            if (i % prime[j] == 0) break;",
			"        }",
			"    }",
			"}"
		],
		"description": "Sieve of Eratosthenes implementation"
	},
	"log2_binary Function": {
		"prefix": "log2binary",
		"body": [
			"int log2_binary(unsigned int n) {",
			"    if (n == 0) {",
			"        return -1;",
			"    }",
			"    int res = 0;",
			"    while (n > 1) {",
			"        n >>= 1;",
			"        ++res;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "A function to compute the binary logarithm (floor(log2(n))) of an unsigned integer."
	},
	"combinatorics": {
		"prefix": "combinatroic",
		"body": [
			"int modInverse(int a) { return a <= 1 ? a : MOD - (MOD/a) * modInverse(MOD % a) % MOD; }",
			"const int MAXN = 100005;",
			"int fac[MAXN+1],invfac[MAXN+1];",
			"void precomputeInverses(){",
			"    fac[0] = 1;",
			"    for(int i = 1;i<=MAXN;i++)fac[i] = (fac[i-1]*i)%MOD;",
			"    invfac[MAXN] = modInverse(fac[MAXN]);",
			"    for (int i = MAXN - 1; i >= 0; i--)",
			"        invfac[i] = (invfac[i + 1] * (i + 1)) % MOD;",
			"}",
			"int nCr(int n,int r){return ((fac[n]*invfac[r]%MOD)*invfac[n-r])%MOD;}"
		],
		"description": "nCr using modInverse and permutation"
	},
	"graph_successor": {
		"prefix": "successor_graph",
		"body": [
			"vector<vector<int>> successor_list;",
			"void precompute_successor(vector<int> &f_graph) {",
			"    int n = f_graph.size();",
			"    int max_jump = log2_binary(n) + 1;",
			"",
			"    vector<vector<int>> successorlist(n, vector<int>(max_jump + 1, -1));",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        successorlist[i][0] = i;",
			"        successorlist[i][1] = f_graph[i];",
			"    }",
			"",
			"    for (int j = 2; j <= max_jump; ++j) {",
			"        for (int i = 0; i < n; ++i) {",
			"            int mid = successorlist[i][j - 1];",
			"            if (mid != -1) {",
			"                successorlist[i][j] = successorlist[mid][j - 1];",
			"            }",
			"        }",
			"    }",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        cout << \"Node \" << i << \": \";",
			"        for (int j = 0; j <= max_jump; ++j) {",
			"            cout << successorlist[i][j] << \" \";",
			"        }",
			"        cout << endl;",
			"    }",
			"    ::successor_list.clear();",
			"    ::successor_list = successorlist;",
			"}",
			"",
			"int get_k_successor(int node, int k) {",
			"    int stp = 0;",
			"    while (k > 0 && node != -1) {",
			"        if (k & 1) {",
			"            node = successor_list[node][stp];",
			"        }",
			"        k >>= 1; ",
			"        ++stp; ",
			"    }",
			"    return node;",
			"}"
		],
		"description": "Precomputes the successor table for a given graph."
	},
	"01 BFS": {
		"prefix": "01 bfs",
		"body": [
			"void o1bfs(vector<vector<node>> &adjl, int src = 0) {",
			"    int n = adjl.size();",
			"    vector<int> dist(n, INT32_MAX);",
			"",
			"    deque<int> dq;",
			"    dist[src] = 0;",
			"    dq.push_back(src);",
			"",
			"    while (!dq.empty()) {",
			"        int cur = dq.front();",
			"        dq.pop_front();",
			"        for (auto &edge : adjl[cur]) {",
			"            int nbor = edge.dest;",
			"            int wt = edge.weight;",
			"            if (dist[cur] + wt < dist[nbor]) {",
			"                dist[nbor] = dist[cur] + wt;",
			"                if (wt == 0)",
			"                    dq.push_front(nbor);",
			"                else",
			"                    dq.push_back(nbor);",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "0-1 BFS algorithm implementation"
	},
	"DSU Class Template": {
		"prefix": "dsu",
		"body": [
			"class DSU {",
			"public:",
			"    vector<int> parent, rank;",
			"",
			"    DSU(int n) : parent(n), rank(n, 0) {",
			"        iota(parent.begin(), parent.end(), 0);",
			"    }",
			"",
			"    int find(int node) {",
			"        if (parent[node] != node)",
			"            parent[node] = find(parent[node]);",
			"        return parent[node];",
			"    }",
			"",
			"    void unionSets(int a, int b) {",
			"        a = find(a);",
			"        b = find(b);",
			"        if (a == b)",
			"            return;",
			"",
			"        if (rank[a] < rank[b])",
			"            swap(a, b);",
			"        parent[b] = a;",
			"        if (rank[a] == rank[b])",
			"            rank[a]++;",
			"    }",
			"};"
		],
		"description": "Disjoint Set Union (DSU) class template with path compression and union by rank"
	},
	"Topological Sort Function": {
		"prefix": "topologicalSort",
		"body": [
			"vector<int> topologicalSort(vector<vector<int>>& adjl) {",
			"    vector<int> topSort; topSort.reserve(adjl.size());",
			"    queue<int> q; vector<int> indegree(adjl.size());",
			"    for (auto i : adjl) for (auto j : i) indegree[j]++;",
			"    for (int i = 0; i < adjl.size(); ++i) if (indegree[i] == 0) q.push(i);",
			"    while (!q.empty()) {",
			"        int node = q.front(); q.pop();",
			"        for (auto j : adjl[node]) {",
			"            indegree[j]--; if (indegree[j] == 0) q.push(j);",
			"        }",
			"        topSort.push_back(node);",
			"    }",
			"    return topSort;",
			"}"
		],
		"description": "Compact topological sort function"
	},
	"Dijkstra Function": {
		"prefix": "dijkstra",
		"body": [
			"void dijkstra(int x, vector<vector<pii>>& adjl) {",
			"    const int INF = 1e18;",
			"    int s = x;",
			"    vi d(adjl.size(), INF);",
			"    vector<bool> processed(adjl.size(), false);",
			"    d[s] = 0;",
			"    priority_queue<pii, vector<pii>, greater<pii>> q;",
			"    q.push({0, s});",
			"    ",
			"    while (!q.empty()) {",
			"        int a = q.top().second;",
			"        q.pop();",
			"        ",
			"        if (processed[a]) continue;",
			"        processed[a] = true;",
			"        ",
			"        for (auto& u : adjl[a]) {",
			"            int b = u.first, w = u.second;",
			"            if (d[a] + w < d[b]) {",
			"                d[b] = d[a] + w;",
			"                q.push({d[b], b});",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Dijkstra's algorithm function without printing"
	},
	"Kruskal Function": {
		"prefix": "kruskal",
		"body": [
			"void Kruskal(vector<Edge>& edges,int n) {",
			"    DSU d(n);",
			"    int cost = 0;",
			"    sort(all(edges));",
			"    vector<Edge> result;",
			"    for (auto e : edges) {",
			"        if (d.find(e.u) != d.find(e.v)) {",
			"            cost += e.weight;",
			"            result.push_back(e);",
			"            d.unionSets(e.u, e.v);",
			"        }",
			"    }",
			"}"
		],
		"description": "Kruskal's Algorithm Function"
	},
	"SegmentTree Class": {
		"prefix": "segmenttree",
		"body": [
			"/// @brief supports queries of the form",
			"///     set(idx,val) : idx as in your normal array index or the actual number itself",
			"///     sum(left,right) : assosciative operation(*) on [left,right)",
			"class SegmentTree{",
			"    public:",
			"    int sz;//size is power of 2",
			"    vector<int> segtree;",
			"    public:",
			"    SegmentTree(int n){ sz = 1; while(sz <=n)sz*=2;segtree.resize(2*sz);}",
			"    void set(int i,int val,int x,int lx,int rx){",
			"        if(rx-lx == 1){segtree[x] = val;return;}",
			"        int m = (lx+rx)/2;",
			"        if(i < m ){set(i,val,2*x+1,lx,m);}//set in the left child",
			"        else{set(i,val,2*x+2,m,rx);}//set in the right child",
			"        segtree[x] = segtree[2*x+1]+segtree[2*x+2];//modify for other type of queries",
			"    }",
			"    void set(int i,int val){set(i,val,0,0,sz);}",
			"    int sum(int l,int r,int x,int lx,int rx){",
			"        if(lx >= r || l >= rx)return 0;",
			"        if(lx >= l && rx <= r)return segtree[x];",
			"        int m = (lx+rx)/2;",
			"        int s1 = sum(l,r,2*x+1,lx,m);",
			"        int s2 = sum(l,r,2*x+2,m,rx);",
			"        return s1+s2;",
			"    }",
			"    int sum(int l,int r){return sum(l,r,0,0,sz);}",
			"};"
		],
		"description": "C++ SegmentTree Class"
	},
	"Indexed Set with Comments": {
		"prefix": "indexed_set",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace __gnu_pbds;",
			"// Define an indexed_set using GNU PBDS",
			"typedef tree<int, null_type, less<int>, rb_tree_tag,",
			"tree_order_statistics_node_update> indexed_set;",
			"// - find_by_order(k): Returns an iterator to the k-th element (0-based index) in the set,Example: If the set contains {10, 20, 30}, find_by_order(1) returns an iterator to 20.",
			"// - order_of_key(x): Returns the number of elements strictly smaller than x. Example: If the set contains {10, 20, 30}, order_of_key(25) returns 2."
		],
		"description": "Snippet for indexed_set using GNU PBDS with function explanations"
	},
	"Header": {
		"prefix": "Header",
		"body": [
			"#ifndef ${1:${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}}",
			"#define ${1:${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}}",
			"",
			"$0",
			"",
			"#endif"
		]
	},
	"LCA Class": {
		"prefix": "lca_class",
		"body": [
			"class LCA {",
			"public:",
			"    struct node {",
			"        int id;",
			"        int depth;",
			"        bool operator<(const node& other) const {",
			"            return this->depth < other.depth;",
			"        }",
			"    };",
			"",
			"    class SegmentTree {",
			"    public:",
			"        int sz;",
			"        vector<node> segtree;",
			"",
			"        SegmentTree(int n) {",
			"            sz = 1;",
			"            while (sz <= n) sz *= 2;",
			"            segtree.resize(2 * sz, {-1, INT32_MAX});",
			"        }",
			"",
			"        void set(int i, node val, int x, int lx, int rx) {",
			"            if (rx - lx == 1) {",
			"                segtree[x] = val;",
			"                return;",
			"            }",
			"            int m = (lx + rx) / 2;",
			"            if (i < m)",
			"                set(i, val, 2 * x + 1, lx, m);",
			"            else",
			"                set(i, val, 2 * x + 2, m, rx);",
			"            segtree[x] = min(segtree[2 * x + 1], segtree[2 * x + 2]);",
			"        }",
			"",
			"        void set(int i, node val) {",
			"            set(i, val, 0, 0, sz);",
			"        }",
			"",
			"        node sum(int l, int r, int x, int lx, int rx) {",
			"            if (lx >= r || l >= rx) return {-1, 1000000};",
			"            if (lx >= l && rx <= r) return segtree[x];",
			"            int m = (lx + rx) / 2;",
			"            node s1 = sum(l, r, 2 * x + 1, lx, m);",
			"            node s2 = sum(l, r, 2 * x + 2, m, rx);",
			"            return min(s1, s2);",
			"        }",
			"",
			"        node sum(int l, int r) {",
			"            return sum(l, r, 0, 0, sz);",
			"        }",
			"    };",
			"",
			"    vector<node> dfs;",
			"    vector<int> startpos;",
			"",
			"    void tdfs(int s, int p, int depth, vector<vector<int>>& adjl) {",
			"        startpos[s] = startpos[s] == -1 ? dfs.size() : startpos[s];",
			"        dfs.push_back({s, depth});",
			"        for (auto i : adjl[s]) {",
			"            if (i != p) {",
			"                tdfs(i, s, depth + 1, adjl);",
			"                dfs.push_back({s, depth});",
			"            }",
			"        }",
			"    }",
			"",
			"    SegmentTree st;",
			"",
			"    LCA(vector<vector<int>>& adjl) : st(2 * adjl.size()), startpos(adjl.size(), -1) {",
			"        tdfs(0, -1, 0, adjl);",
			"        for (int i = 0; i < dfs.size(); i++) st.set(i, dfs[i]);",
			"    }",
			"",
			"    pair<int, int> find_lca(int a, int b) {",
			"        if (startpos[a] > startpos[b]) swap(a, b);",
			"        return {",
			"            st.sum(startpos[a], startpos[b] + 1).id + 1,",
			"            dfs[startpos[a]].depth + dfs[startpos[b]].depth -",
			"            2 * dfs[startpos[st.sum(startpos[a], startpos[b] + 1).id]].depth",
			"        };",
			"    }",
			"};"
		],
		"description": "Class for Lowest Common Ancestor (LCA) with Segment Tree."
	}
}
