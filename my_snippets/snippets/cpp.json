{
	"Boilerplate": {
		"prefix": "BoilerPlate",
		"body": [
			"// clang-format off",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define USACO(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);",
			"#define int long long",
			"#define MOD 1000000007",
			"#define vi vector<int>",
			"#define vvi vector<vector<int>>",
			"#define pii pair<int,int>",
			"#define vvpi vector<vector<pair<int,int>>>",
			"#define all(x) (x).begin(),(x).end()",
			"#define input(v, n) for (int i = 0; i < n; i++) cin >> v[i];",
			"",
			"struct Edge{int u,v,weight;bool operator<(Edge const&other)const{return weight < other.weight;}};",
			"template<typename T1,typename T2> ostream& operator<<(ostream& out,const pair<T1,T2> a){out<<a.first<<\" \"<<a.second;return out;}",
			"// clang-format on",
			"",
			"void compute()",
			"{",
			"    $0",
			"}",
			"signed main()",
			"{",
			"ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);",
			"    int t = 1;",
			"    cin>>t;",
			"    while(t--)compute();",
			"    return 0;",
			"}"
		],
		"description": "Log output to console"
	},
	"BinarySearch": {
		"prefix": "binary_template",
		"body": [
			"",
			"auto check = [&](int x)",
			"{",
			"    ${1}",
			"    return true; ",
			"};",
			"",
			"int lo = -1,hi=1e18;",
			"while (lo +1  < hi)",
			"{",
			"    int mid = lo + (hi - lo) / 2;",
			"    if (check(mid))",
			"    {",
			"        hi = mid; ",
			"    }",
			"    else ",
			"    {",
			"        lo = mid; ",
			"    }",
			"}",
			"",
			"cout<<lo<<\"\\n\"; ",
			""
		]
	},
	"exponentiate": {
		"prefix": "exponentiate",
		"body": [
			"int bin_pow(int x,int n,int m = 1e9+7)",
			"{",
			"    if (n == 0) return 1%m;",
			"    long long u = bin_pow(x,n/2,m);",
			"    u = (u*u)%m;",
			"    if (n%2 == 1) u = (u*x)%m;",
			"        return u;",
			"}"
		]
	},
	"BFS Function": {
		"prefix": "bfs",
		"body": [
			"void bfs(vector<vector<int>>&adjl) {",
			"    int s = 0;",
			"    queue<int> q;",
			"    q.push(s);",
			"",
			"    vector<bool> visited(adjl.size(), false); ",
			"    vector<int> distance(adjl.size(), 0);",
			"",
			"    visited[s] = true;",
			"    distance[s] = 0;",
			"",
			"    while (!q.empty()) {",
			"        int n = q.front();",
			"        q.pop();",
			"",
			"        ${0}",
			"        for (auto i : adjl[n]) {",
			"            if (visited[i])",
			"                continue;",
			"            distance[i] = distance[n] + 1; ",
			"            visited[i] = true;            ",
			"            q.push(i);                     ",
			"        }",
			"    }",
			"}"
		],
		"description": "Breadth-First Search (BFS) function implementation"
	},
	"DFS Function": {
		"prefix": "dfs",
		"body": [
			"void dfs(int s, vector<vector<int>> &adjl,vector<bool>& visited)",
			"{",
			"    if (visited[s])",
			"        return;",
			"    visited[s] = true;",
			"    // process node s",
			"    for (auto u : adjl[s])",
			"    {",
			"        dfs(u,adjl,visited);",
			"    }",
			"}"
		]
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"const int MAXN = 1000100;",
			"std::vector<int> prime;",
			"bool is_composite[MAXN];",
			"",
			"void sieve(int n) {",
			"    std::fill(is_composite, is_composite + n, false);",
			"    for (int i = 2; i < n; ++i) {",
			"        if (!is_composite[i]) prime.push_back(i);",
			"        for (int j = 0; j < prime.size() && i * prime[j] < n; ++j) {",
			"            is_composite[i * prime[j]] = true;",
			"            if (i % prime[j] == 0) break;",
			"        }",
			"    }",
			"}"
		],
		"description": "Sieve of Eratosthenes implementation"
	},
	"log2_binary Function": {
		"prefix": "log2binary",
		"body": [
			"int log2_binary(unsigned int n) {",
			"    if (n == 0) {",
			"        return -1;",
			"    }",
			"    int res = 0;",
			"    while (n > 1) {",
			"        n >>= 1;",
			"        ++res;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "A function to compute the binary logarithm (floor(log2(n))) of an unsigned integer."
	},
	"combinatorics": {
		"prefix": "combinatroic",
		"body": [
			"int modInverse(int a) { return a <= 1 ? a : MOD - (MOD/a) * modInverse(MOD % a) % MOD; }",
			"const int MAXN = 2000005;",
			"int fac[MAXN+1],invfac[MAXN+1];",
			"void precomputeInverses(){",
			"    fac[0] = 1;",
			"    for(int i = 1;i<=MAXN;i++)fac[i] = (fac[i-1]*i)%MOD;",
			"    invfac[MAXN] = modInverse(fac[MAXN]);",
			"    for (int i = MAXN - 1; i >= 0; i--)",
			"        invfac[i] = (invfac[i + 1] * (i + 1)) % MOD;",
			"}",
			"int nCr(int n,int r){return ((fac[n]*invfac[r]%MOD)*invfac[n-r])%MOD;}"
		],
		"description": "nCr using modInverse and permutation"
	},
	"inversePermutation": {
		"prefix": "inversePermutation",
		"description": "Compute the inverse of a given permutation vector with optional 1-based indexing",
		"body": [
			"#include <vector>",
			"std::vector<int> inversePermutation(const std::vector<int>& perm, bool elementsStartFromOne = false) {",
			"    int n = perm.size();",
			"    std::vector<int> inverse(n + elementsStartFromOne);",
			"    for (int i = 0; i < n; ++i) {",
			"        inverse[permut[i]] = i + elementsStartFromOne;",
			"    }",
			"    return inverse;",
			"}"
		],
		"scope": "cpp"
	},
	"graph_successor": {
		"prefix": "successor_graph",
		"body": [
			"vector<vector<int>> successor_list;",
			"void precompute_successor(vector<int> &f_graph) {",
			"    int n = f_graph.size();",
			"    int max_jump = log2_binary(n) + 1;",
			"",
			"    vector<vector<int>> successorlist(n, vector<int>(max_jump + 1, -1));",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        successorlist[i][0] = i;",
			"        successorlist[i][1] = f_graph[i];",
			"    }",
			"",
			"    for (int j = 2; j <= max_jump; ++j) {",
			"        for (int i = 0; i < n; ++i) {",
			"            int mid = successorlist[i][j - 1];",
			"            if (mid != -1) {",
			"                successorlist[i][j] = successorlist[mid][j - 1];",
			"            }",
			"        }",
			"    }",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        cout << \"Node \" << i << \": \";",
			"        for (int j = 0; j <= max_jump; ++j) {",
			"            cout << successorlist[i][j] << \" \";",
			"        }",
			"        cout << endl;",
			"    }",
			"    ::successor_list.clear();",
			"    ::successor_list = successorlist;",
			"}",
			"",
			"int get_k_successor(int node, int k) {",
			"    int stp = 0;",
			"    while (k > 0 && node != -1) {",
			"        if (k & 1) {",
			"            node = successor_list[node][stp];",
			"        }",
			"        k >>= 1; ",
			"        ++stp; ",
			"    }",
			"    return node;",
			"}"
		],
		"description": "Precomputes the successor table for a given graph."
	},
	"01 BFS": {
		"prefix": "01 bfs",
		"body": [
			"void o1bfs(vector<vector<node>> &adjl, int src = 0) {",
			"    int n = adjl.size();",
			"    vector<int> dist(n, INT32_MAX);",
			"",
			"    deque<int> dq;",
			"    dist[src] = 0;",
			"    dq.push_back(src);",
			"",
			"    while (!dq.empty()) {",
			"        int cur = dq.front();",
			"        dq.pop_front();",
			"        for (auto &edge : adjl[cur]) {",
			"            int nbor = edge.dest;",
			"            int wt = edge.weight;",
			"            if (dist[cur] + wt < dist[nbor]) {",
			"                dist[nbor] = dist[cur] + wt;",
			"                if (wt == 0)",
			"                    dq.push_front(nbor);",
			"                else",
			"                    dq.push_back(nbor);",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "0-1 BFS algorithm implementation"
	},
	"DSU Class Template": {
		"prefix": "dsu",
		"body": [
			"class DSU {",
			"public:",
			"    vector<int> parent, rank;",
			"",
			"    DSU(int n) : parent(n), rank(n, 0) {",
			"        iota(parent.begin(), parent.end(), 0);",
			"    }",
			"",
			"    int find(int node) {",
			"        if (parent[node] != node)",
			"            parent[node] = find(parent[node]);",
			"        return parent[node];",
			"    }",
			"",
			"    void unionSets(int a, int b) {",
			"        a = find(a);",
			"        b = find(b);",
			"        if (a == b)",
			"            return;",
			"",
			"        if (rank[a] < rank[b])",
			"            swap(a, b);",
			"        parent[b] = a;",
			"        if (rank[a] == rank[b])",
			"            rank[a]++;",
			"    }",
			"};"
		],
		"description": "Disjoint Set Union (DSU) class template with path compression and union by rank"
	},
	"Topological Sort Function": {
		"prefix": "topologicalSort",
		"body": [
			"vector<int> topologicalSort(vector<vector<int>>& adjl) {",
			"    vector<int> topSort; topSort.reserve(adjl.size());",
			"    queue<int> q; vector<int> indegree(adjl.size());",
			"    for (auto i : adjl) for (auto j : i) indegree[j]++;",
			"    for (int i = 0; i < adjl.size(); ++i) if (indegree[i] == 0) q.push(i);",
			"    while (!q.empty()) {",
			"        int node = q.front(); q.pop();",
			"        for (auto j : adjl[node]) {",
			"            indegree[j]--; if (indegree[j] == 0) q.push(j);",
			"        }",
			"        topSort.push_back(node);",
			"    }",
			"    return topSort;",
			"}"
		],
		"description": "Compact topological sort function"
	},
	"Dijkstra Function": {
		"prefix": "dijkstra",
		"body": [
			"void dijkstra(int x, vector<vector<pii>>& adjl) {",
			"    const int INF = 1e18;",
			"    int s = x;",
			"    vi d(adjl.size(), INF);",
			"    vector<bool> processed(adjl.size(), false);",
			"    d[s] = 0;",
			"    priority_queue<pii, vector<pii>, greater<pii>> q;",
			"    q.push({0, s});",
			"    ",
			"    while (!q.empty()) {",
			"        int a = q.top().second;",
			"        q.pop();",
			"        ",
			"        if (processed[a]) continue;",
			"        processed[a] = true;",
			"        ",
			"        for (auto& u : adjl[a]) {",
			"            int b = u.first, w = u.second;",
			"            if (d[a] + w < d[b]) {",
			"                d[b] = d[a] + w;",
			"                q.push({d[b], b});",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Dijkstra's algorithm function without printing"
	},
	"Kruskal Function": {
		"prefix": "kruskal",
		"body": [
			"void Kruskal(vector<Edge>& edges,int n) {",
			"    DSU d(n);",
			"    int cost = 0;",
			"    sort(all(edges));",
			"    vector<Edge> result;",
			"    for (auto e : edges) {",
			"        if (d.find(e.u) != d.find(e.v)) {",
			"            cost += e.weight;",
			"            result.push_back(e);",
			"            d.unionSets(e.u, e.v);",
			"        }",
			"    }",
			"}"
		],
		"description": "Kruskal's Algorithm Function"
	},
	"SegmentTree Class": {
		"prefix": "segmenttree",
		"body": [
			"/// @brief supports queries of the form",
			"///     set(idx,val) : idx as in your normal array index or the actual number itself",
			"///     sum(left,right) : assosciative operation(*) on [left,right)",
			"template <class T=int>",
			"class SegmentTree{",
			"    public:",
			"    int sz;//size is power of 2",
			"    vector<T> segtree;",
			"    T combine(T &a,T&b){",
			"        return max(a,b);",
			"    }",
			"    public:",
			"    SegmentTree(int n){ sz = 1; while(sz <=n)sz*=2;segtree.resize(2*sz);}",
			"    void set(int i,int val,int x,int lx,int rx){",
			"        if(rx-lx == 1){segtree[x] = val;return;}",
			"        int m = (lx+rx)/2;",
			"        if(i < m ){set(i,val,2*x+1,lx,m);}//set in the left child",
			"        else{set(i,val,2*x+2,m,rx);}//set in the right child",
			"        // segtree[x] = segtree[2*x+1]+segtree[2*x+2];//modify for other type of queries",
			"        segtree[x] = combine(segtree[2*x+1],segtree[2*x+2]);",
			"    }",
			"    void set(int i,int val){set(i,val,0,0,sz);}",
			"    int sum(int l,int r,int x,int lx,int rx){",
			"        if(lx >= r || l >= rx)return 0;",
			"        if(lx >= l && rx <= r)return segtree[x];",
			"        int m = (lx+rx)/2;",
			"        int s1 = sum(l,r,2*x+1,lx,m);",
			"        int s2 = sum(l,r,2*x+2,m,rx);",
			"        return combine(s1,s2);",
			"    }",
			"    int sum(int l,int r){return sum(l,r,0,0,sz);}",
			"};"
		],
		"description": "C++ SegmentTree Class"
	},
	"Indexed Set with Comments": {
		"prefix": "indexed_set",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace __gnu_pbds;",
			"// Define an indexed_set using GNU PBDS",
			"typedef tree<int, null_type, less<int>, rb_tree_tag,",
			"tree_order_statistics_node_update> indexed_set;",
			"//[WARNING]duplicate not allowed use them as pair<int,int>",
			"// - find_by_order(k): Returns an iterator to the k-th element (0-based index) in the set,Example: If the set contains {10, 20, 30}, find_by_order(1) returns an iterator to 20.",
			"// - order_of_key(x): Returns the number of elements strictly smaller than x. Example: If the set contains {10, 20, 30}, order_of_key(25) returns 2."
		],
		"description": "Snippet for indexed_set using GNU PBDS with function explanations"
	},
	"Header": {
		"prefix": "Header",
		"body": [
			"#ifndef ${1:${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}}",
			"#define ${1:${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}}",
			"",
			"$0",
			"",
			"#endif"
		]
	},
	"LCA Class": {
		"prefix": "lca_class",
		"body": [
			"class LCA {",
			"   private:",
			"    static constexpr int LOG = 32;",
			"    int m_root;",
			"    int m_sz;",
			"    vector<vector<int>> m_adjl;",
			"    vector<vector<int>> m_ancestors;",
			"    vector<int> m_level;",
			"",
			"   private:",
			"    void dfs1(int node, int parent, int dist) {",
			"        m_level[node] = dist;",
			"        m_ancestors[node][0] = parent;",
			"        for (auto i : m_adjl[node])",
			"            if (i == parent)",
			"                continue;",
			"            else",
			"                dfs1(i, node, dist + 1);",
			"    }",
			"    void init() {",
			"        m_level[m_root] = 0;",
			"        dfs1(m_root, -1, 0);",
			"        m_ancestors[m_root][0] = m_root;",
			"        for (int j = 1; j < LOG; j++) {",
			"            for (int i = 0; i < m_sz; i++) {",
			"                m_ancestors[i][j] = m_ancestors[m_ancestors[i][j - 1]][j - 1];",
			"            }",
			"        }",
			"    }",
			"",
			"   public:",
			"    LCA(vector<vector<int>>& adjl, int root = 0)",
			"        : m_adjl(adjl),",
			"          m_root(root),",
			"          m_sz(adjl.size()),",
			"          m_ancestors(adjl.size(), vector<int>(LOG)),",
			"          m_level(adjl.size()) {",
			"        init();",
			"    }",
			"    int getLCA(int a, int b) {",
			"        if (m_level[a] > m_level[b]) swap(a, b);",
			"        int diff = m_level[b] - m_level[a];",
			"        for (int i = 0; i < LOG; i++) {",
			"            if ((diff >> i) & 1) {",
			"                b = m_ancestors[b][i];",
			"            }",
			"        }",
			"        if (a == b) return a;",
			"        for (int i = LOG - 1; i >= 0; --i) {",
			"            if (m_ancestors[a][i] != m_ancestors[b][i]) {",
			"                a = m_ancestors[a][i];",
			"                b = m_ancestors[b][i];",
			"            }",
			"        }",
			"        return m_ancestors[a][0];",
			"    }",
			"    int getDist(int a, int b) {",
			"        int lca = getLCA(a, b);",
			"        return m_level[a] + m_level[b] - 2 * m_level[lca];",
			"    }",
			"};"
		],
		"description": "Class for Lowest Common Ancestor (LCA) with Segment Tree."
	},
	"Bellman-Ford Algorithm with Struct": {
		"prefix": "bellman-ford-struct",
		"body": [
			"void bellman(int s, int n, vector<Edge> &edges) {",
			"\tvi dist(n, LONG_MAX);",
			"\tdist[s] = 0;",
			"\tfor (int i = 1; i <= n - 1; i++) {",
			"\t\tfor (auto e : edges) {",
			"\t\t\tdist[e.v] = min(dist[e.u] + e.weight, dist[e.v]);",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "Bellman-Ford Algorithm using struct Edge"
	},
	"Floyd-Warshall Algorithm with Struct": {
		"prefix": "floyd-warshall-struct",
		"body": [
			"void floydwarshall(int n, vector<Edge>& edges) {",
			"\tconst int INF = INT32_MAX;",
			"\tvvi d(n, vi(n, INF));",
			"\tfor (auto e : edges) {",
			"\t\tint a = e.u, b = e.v, w = e.weight;",
			"\t\td[a][b] = min(d[a][b], w);",
			"\t}",
			"\tfor (int k = 0; k < n; ++k) {",
			"\t\tfor (int i = 0; i < n; ++i) {",
			"\t\t\tfor (int j = 0; j < n; ++j) {",
			"\t\t\t\tif (d[i][k] < INF && d[k][j] < INF)",
			"\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "Floyd-Warshall Algorithm using struct Edge"
	},
	"Two-Sat Solver": {
		"prefix": "twosat",
		"body": [
			"class TwoSatSolver {",
			"   private:",
			"    int m_vars;",
			"    int m_vertices;",
			"    vector<vector<int>> m_adjl, m_adjl_t;",
			"    vector<bool> used;",
			"    vector<int> order, comp;",
			"",
			"   public:",
			"    vector<bool> assignment;",
			"",
			"   private:",
			"    void dfs1(int v) {",
			"        used[v] = true;",
			"        for (auto i : m_adjl[v])",
			"            if (!used[i]) dfs1(i);",
			"        order.push_back(v);",
			"    }",
			"    void dfs2(int v, int cl) {",
			"        comp[v] = cl;",
			"        used[v] = true;",
			"        for (auto i : m_adjl_t[v])",
			"            if (comp[i] == -1) dfs2(i, cl);",
			"    }",
			"",
			"   public:",
			"    TwoSatSolver(int n_vars)",
			"        : m_vars(n_vars),",
			"          m_vertices(m_vars * 2ll),",
			"          m_adjl(m_vertices),",
			"          m_adjl_t(m_vertices),",
			"          used(m_vertices),",
			"          order(),",
			"          comp(m_vertices, -1),",
			"          assignment(m_vars) {",
			"        order.reserve(m_vertices);",
			"    }",
			"    bool solve_2SAT() {",
			"        order.clear();",
			"        used.assign(m_vertices, false);",
			"        comp.assign(m_vertices, -1);",
			"        assignment.assign(m_vars, false);",
			"",
			"        for (int i = 0; i < m_vertices; i++)",
			"            if (!used[i]) dfs1(i);",
			"        reverse(all(order));",
			"",
			"        int j{};",
			"        for (int i = 0; i < m_vertices; i++) {",
			"            if (comp[order[i]] == -1) dfs2(order[i], j++);",
			"        }",
			"        for (int i = 0; i < m_vertices; i += 2) {",
			"            if (comp[i] == comp[i + 1]) return false;",
			"            assignment[i / 2] = comp[i] > comp[i + 1];",
			"        }",
			"        return true;",
			"    }",
			"    // na and nb signify the signs of a and b(false means negation)",
			"    void add_disjunction(int a, bool na, int b, bool nb) {",
			"        na = !na;",
			"        nb = !nb;",
			"        a = 2 * a ^ na;",
			"        b = 2 * b ^ nb;",
			"        int neg_a = a ^ 1;",
			"        int neg_b = b ^ 1;",
			"        m_adjl[neg_a].push_back(b);",
			"        m_adjl[neg_b].push_back(a);",
			"        m_adjl_t[b].push_back(neg_a);",
			"        m_adjl_t[a].push_back(neg_b);",
			"    }",
			"};"
		]
	},
	"Suffix-Set of string": {
		"prefix": "suffixSet",
		"body": [
			"void radix_sort(vector<pair<pair<int, int>, int>>& a) {",
			"    int n = a.size();",
			"    // iter on second",
			"    {",
			"        vector<int> cnt(n);",
			"        for (auto x : a) {",
			"            cnt[x.first.second]++;",
			"        }",
			"        vector<pair<pair<int, int>, int>> a_new(n);",
			"        vector<int> pos(n);",
			"        pos[0] = 0;",
			"        for (int i = 1; i < n; i++) {",
			"            pos[i] = pos[i - 1] + cnt[i - 1];",
			"        }",
			"        for (auto x : a) {",
			"            int i = x.first.second;",
			"            a_new[pos[i]] = x;",
			"            pos[i]++;",
			"        }",
			"        a = a_new;",
			"    }",
			"    // iter on first",
			"    {",
			"        vector<int> cnt(n);",
			"        for (auto x : a) {",
			"            cnt[x.first.first]++;",
			"        }",
			"        vector<pair<pair<int, int>, int>> a_new(n);",
			"        vector<int> pos(n);",
			"        pos[0] = 0;",
			"        for (int i = 1; i < n; i++) {",
			"            pos[i] = pos[i - 1] + cnt[i - 1];",
			"        }",
			"        for (auto x : a) {",
			"            int i = x.first.first;",
			"            a_new[pos[i]] = x;",
			"            pos[i]++;",
			"        }",
			"        a = a_new;",
			"    }",
			"}",
			"/// credits : Paksha @ITMO university",
			"vector<int> suffixSet(string& s) {",
			"    s += '$';  // less than every other character",
			"    int sz = s.size();",
			"    vi p(sz), c(sz);  // p is the ordering and c is the equivalence class",
			"    {",
			"        // k = 0",
			"        vector<pair<char, int>> a(sz);",
			"        for (int i = 0; i < sz; ++i) a[i] = {s[i], i};",
			"        sort(a.begin(), a.end());",
			"        for (int i = 0; i < sz; i++) p[i] = a[i].second;",
			"        c[p[0]] = 0;",
			"        for (int i = 1; i < sz; i++) {",
			"            if (a[i].first == a[i - 1].first)",
			"                c[p[i]] = c[p[i - 1]];",
			"            else",
			"                c[p[i]] = 1 + c[p[i - 1]];",
			"        }",
			"    }",
			"    int k = 0;  // current phase (length is 2^k)",
			"    while ((1ll << k) < sz) {",
			"        vector<pair<pair<int, int>, int>> a(",
			"            sz);  // stores classes of left and right substring and its idx",
			"        for (int i = 0; i < sz; ++i)",
			"            a[i] = {{c[i], c[(i + (1ll << k)) % sz]}, i};  // %sz to wrap around",
			"",
			"        radix_sort(a);",
			"",
			"        for (int i = 0; i < sz; i++) p[i] = a[i].second;",
			"        c[p[0]] = 0;",
			"        for (int i = 1; i < sz; i++) {",
			"            if (a[i].first == a[i - 1].first)",
			"                c[p[i]] = c[p[i - 1]];",
			"            else",
			"                c[p[i]] = 1 + c[p[i - 1]];",
			"        }",
			"        ++k;",
			"    }",
			"    s.pop_back()",
			"    return p;",
			"    //first element is $ don't forget that",
			"}"
		]
	}
}
