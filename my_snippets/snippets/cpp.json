{
	"Boilerplate": {
		"prefix": "BoilerPlate",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define USACO(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);",
			"#define int long long",
			"#define MOD 1000000007",
			"#define vi vector<int>",
			"#define vvi vector<vector<int>>",
			"#define pii pair<int,int>",
			"#define all(x) (x).begin(),(x).end()",
			"#define input(v, n) for (int i = 0; i < n; i++) cin >> v[i];",
			"",
			"struct Edge{int u,v,weight;bool operator<(Edge const&other)const{return weight < other.weight;}};",
			"template<typename T1,typename T2> ostream& operator<<(ostream& out,const pair<T1,T2> a){out<<a.first<<\" \"<<a.second;return out;}",
			"",
			"void compute()",
			"{",
			"    $0",
			"}",
			"signed main()",
			"{",
			"ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);",
			"    int t = 1;",
			"    cin>>t;",
			"    while(t--)compute();",
			"    return 0;",
			"}"
		],
		"description": "Log output to console"
	},
	"BinarySearch": {
		"prefix": "binary_template",
		"body": [
			"",
			"auto check = [&](int x)",
			"{",
			"    ${1}",
			"    return true; ",
			"};",
			"",
			"int lo = -1,hi=1e19;",
			"while (lo +1  < hi)",
			"{",
			"    int mid = lo + (hi - lo) / 2;",
			"    if (check(mid))",
			"    {",
			"        hi = mid; ",
			"    }",
			"    else ",
			"    {",
			"        lo = mid; ",
			"    }",
			"}",
			"",
			"cout<<lo<<\"\\n\"; ",
			""
		]
	},
	"exponentiate": {
		"prefix": "exponentiate",
		"body": [
			"int bin_pow(int x,int n,int m = 1e9+7)",
			"{",
			"    if (n == 0) return 1%m;",
			"    long long u = bin_pow(x,n/2,m);",
			"    u = (u*u)%m;",
			"    if (n%2 == 1) u = (u*x)%m;",
			"        return u;",
			"}"
		]
	},
	"BFS Function": {
		"prefix": "bfs",
		"body": [
			"void bfs(vector<vector<int>> adjl) {",
			"    int s = 0;",
			"    queue<int> q;",
			"    q.push(s);",
			"",
			"    vector<bool> visited(adjl.size(), false); ",
			"    vector<int> distance(adjl.size(), 0);",
			"",
			"    visited[s] = true;",
			"    distance[s] = 0;",
			"",
			"    while (!q.empty()) {",
			"        int n = q.front();",
			"        q.pop();",
			"",
			"        ${0}",
			"        for (auto i : adjl[n]) {",
			"            if (visited[i])",
			"                continue;",
			"            distance[i] = distance[n] + 1; ",
			"            visited[i] = true;            ",
			"            q.push(i);                     ",
			"        }",
			"    }",
			"}"
		],
		"description": "Breadth-First Search (BFS) function implementation"
	},
	"DFS Function": {
		"prefix": "dfs",
		"body": [
			"void dfs(int s, vector<vector<int>> &adjl,vector<bool>& visited)",
			"{",
			"    if (visited[s])",
			"        return;",
			"    visited[s] = true;",
			"    // process node s",
			"    for (auto u : adjl[s])",
			"    {",
			"        dfs(u,adjl,visited);",
			"    }",
			"}"
		]
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"const int MAXN = 1000000;",
			"std::vector<int> prime;",
			"bool is_composite[MAXN];",
			"",
			"void sieve(int n) {",
			"    std::fill(is_composite, is_composite + n, false);",
			"    for (int i = 2; i < n; ++i) {",
			"        if (!is_composite[i]) prime.push_back(i);",
			"        for (int j = 0; j < prime.size() && i * prime[j] < n; ++j) {",
			"            is_composite[i * prime[j]] = true;",
			"            if (i % prime[j] == 0) break;",
			"        }",
			"    }",
			"}"
		],
		"description": "Sieve of Eratosthenes implementation"
	},
	"log2_binary Function": {
		"prefix": "log2binary",
		"body": [
			"int log2_binary(unsigned int n) {",
			"    if (n == 0) {",
			"        return -1;",
			"    }",
			"    int res = 0;",
			"    while (n > 1) {",
			"        n >>= 1;",
			"        ++res;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "A function to compute the binary logarithm (floor(log2(n))) of an unsigned integer."
	},
	"graph_successor": {
		"prefix": "successor_graph",
		"body": [
			"vector<vector<int>> successor_list;",
			"void precompute_successor(vector<int> &f_graph) {",
			"    int n = f_graph.size();",
			"    int max_jump = log2_binary(n) + 1;",
			"",
			"    vector<vector<int>> successorlist(n, vector<int>(max_jump + 1, -1));",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        successorlist[i][0] = i;",
			"        successorlist[i][1] = f_graph[i];",
			"    }",
			"",
			"    for (int j = 2; j <= max_jump; ++j) {",
			"        for (int i = 0; i < n; ++i) {",
			"            int mid = successorlist[i][j - 1];",
			"            if (mid != -1) {",
			"                successorlist[i][j] = successorlist[mid][j - 1];",
			"            }",
			"        }",
			"    }",
			"",
			"    for (int i = 0; i < n; ++i) {",
			"        cout << \"Node \" << i << \": \";",
			"        for (int j = 0; j <= max_jump; ++j) {",
			"            cout << successorlist[i][j] << \" \";",
			"        }",
			"        cout << endl;",
			"    }",
			"    ::successor_list.clear();",
			"    ::successor_list = successorlist;",
			"}",
			"",
			"int get_k_successor(int node, int k) {",
			"    int stp = 0;",
			"    while (k > 0 && node != -1) {",
			"        if (k & 1) {",
			"            node = successor_list[node][stp];",
			"        }",
			"        k >>= 1; ",
			"        ++stp; ",
			"    }",
			"    return node;",
			"}"
		],
		"description": "Precomputes the successor table for a given graph."
	},
	"01 BFS": {
		"prefix": "01 bfs",
		"body": [
			"void o1bfs(vector<vector<node>> &adjl, int src = 0) {",
			"    int n = adjl.size();",
			"    vector<int> dist(n, INT32_MAX);",
			"",
			"    deque<int> dq;",
			"    dist[src] = 0;",
			"    dq.push_back(src);",
			"",
			"    while (!dq.empty()) {",
			"        int cur = dq.front();",
			"        dq.pop_front();",
			"        for (auto &edge : adjl[cur]) {",
			"            int nbor = edge.dest;",
			"            int wt = edge.weight;",
			"            if (dist[cur] + wt < dist[nbor]) {",
			"                dist[nbor] = dist[cur] + wt;",
			"                if (wt == 0)",
			"                    dq.push_front(nbor);",
			"                else",
			"                    dq.push_back(nbor);",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "0-1 BFS algorithm implementation"
	},
	"DSU Class Template": {
		"prefix": "dsu",
		"body": [
			"class DSU {",
			"public:",
			"    vector<int> parent, rank;",
			"",
			"    DSU(int n) : parent(n), rank(n, 0) {",
			"        iota(parent.begin(), parent.end(), 0);",
			"    }",
			"",
			"    int find(int node) {",
			"        if (parent[node] != node)",
			"            parent[node] = find(parent[node]);",
			"        return parent[node];",
			"    }",
			"",
			"    void unionSets(int a, int b) {",
			"        a = find(a);",
			"        b = find(b);",
			"        if (a == b)",
			"            return;",
			"",
			"        if (rank[a] < rank[b])",
			"            swap(a, b);",
			"        parent[b] = a;",
			"        if (rank[a] == rank[b])",
			"            rank[a]++;",
			"    }",
			"};"
		],
		"description": "Disjoint Set Union (DSU) class template with path compression and union by rank"
	},
	"Topological Sort Function": {
		"prefix": "topologicalSort",
		"body": [
			"vector<int> topologicalSort(vector<vector<int>>& adjl) {",
			"    vector<int> topSort; topSort.reserve(adjl.size());",
			"    queue<int> q; vector<int> indegree(adjl.size());",
			"    for (auto i : adjl) for (auto j : i) indegree[j]++;",
			"    for (int i = 0; i < adjl.size(); ++i) if (indegree[i] == 0) q.push(i);",
			"    while (!q.empty()) {",
			"        int node = q.front(); q.pop();",
			"        for (auto j : adjl[node]) {",
			"            indegree[j]--; if (indegree[j] == 0) q.push(j);",
			"        }",
			"        topSort.push_back(node);",
			"    }",
			"    return topSort;",
			"}"
		],
		"description": "Compact topological sort function"
	},
	"Dijkstra Function": {
		"prefix": "dijkstra",
		"body": [
			"void dijkstra(int x, vector<vector<pii>>& adjl) {",
			"    const int INF = 1e18;",
			"    int s = x;",
			"    vi d(adjl.size(), INF);",
			"    vector<bool> processed(adjl.size(), false);",
			"    d[s] = 0;",
			"    priority_queue<pii, vector<pii>, greater<pii>> q;",
			"    q.push({0, s});",
			"    ",
			"    while (!q.empty()) {",
			"        int a = q.top().second;",
			"        q.pop();",
			"        ",
			"        if (processed[a]) continue;",
			"        processed[a] = true;",
			"        ",
			"        for (auto& u : adjl[a]) {",
			"            int b = u.first, w = u.second;",
			"            if (d[a] + w < d[b]) {",
			"                d[b] = d[a] + w;",
			"                q.push({d[b], b});",
			"            }",
			"        }",
			"    }",
			"}"
		],
		"description": "Dijkstra's algorithm function without printing"
	},
	"Kruskal Function": {
		"prefix": "kruskal",
		"body": [
			"void Kruskal(vector<Edge>& edges,int n) {",
			"    DSU d(n);",
			"    int cost = 0;",
			"    sort(all(edges));",
			"    vector<Edge> result;",
			"    for (auto e : edges) {",
			"        if (d.find(e.u) != d.find(e.v)) {",
			"            cost += e.weight;",
			"            result.push_back(e);",
			"            d.unionSets(e.u, e.v);",
			"        }",
			"    }",
			"}"
		],
		"description": "Kruskal's Algorithm Function"
	},
	"SegmentTree Class": {
		"prefix": "segmenttree",
		"body": [
			"/// @brief supports queries of the form",
			"///     set(idx,val) : idx as in your normal array index or the actual number itself",
			"///     sum(left,right) : assosciative operation(*) on [left,right)",
			"class SegmentTree{",
			"    public:",
			"    int sz;//size is power of 2",
			"    vector<int> segtree;",
			"    public:",
			"    SegmentTree(int n){ sz = 1; while(sz <=n)sz*=2;segtree.resize(2*sz);}",
			"    void set(int i,int val,int x,int lx,int rx){",
			"        if(rx-lx == 1){segtree[x] = val;return;}",
			"        int m = (lx+rx)/2;",
			"        if(i < m ){set(i,val,2*x+1,lx,m);}//set in the left child",
			"        else{set(i,val,2*x+2,m,rx);}//set in the right child",
			"        segtree[x] = segtree[2*x+1]+segtree[2*x+2];//modify for other type of queries",
			"    }",
			"    void set(int i,int val){set(i,val,0,0,sz);}",
			"    int sum(int l,int r,int x,int lx,int rx){",
			"        if(lx >= r || l >= rx)return 0;",
			"        if(lx >= l && rx <= r)return segtree[x];",
			"        int m = (lx+rx)/2;",
			"        int s1 = sum(l,r,2*x+1,lx,m);",
			"        int s2 = sum(l,r,2*x+2,m,rx);",
			"        return s1+s2;",
			"    }",
			"    int sum(int l,int r){return sum(l,r,0,0,sz);}",
			"};"
		],
		"description": "C++ SegmentTree Class"
	},
	"Header": {
		"prefix": "Header",
		"body": [
			"#ifndef ${1:${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}}",
			"#define ${1:${TM_FILENAME/(.*)\\.(.*)/${1:/upcase}_${2:/upcase}/}}",
			"",
			"$0",
			"",
			"#endif"
		]
	}
}
